\section{Solution}
\subsection{Core Language}

\begin{frame}
\tiny{
  K ::= <G, M, Q, S, $L_v$, $L_e$, $\Sigma$> $\hspace{23mm}$ Global Configurations \\
  $\Sigma$ ::= $\bullet$ \ | $\Sigma$ ; <id, v, h>  $\hspace{30mm}$ Local Configurations \\
  h ::= \{ true, false\}\\
  I ::= \{$V_k \mapsto$ id \}\\
  \ \\
  M ::= \{id $\mapsto$ m\} \\
  $m$ ::= $\bullet$ | e.$m$\\
  S ::= \{$v_k$ $\mapsto$ \{true, false\}\}\\
  Q ::= $\bullet$ | e.Q \\
  \ \\
  $v \  \in V$ \ \  set of vertices\\
  $e \ \in E$ \ \ set of edges \\
  id $\in \mathfrak{N}$ \\
  k \ $\in \mathfrak{K}$ \ \ \ is finite
}
\end{frame}

\begin{frame}
  \tiny{
    \textit{P} ::= \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Program \\
    \ \ \ \  | $\overline {\textbf{e}}$ \\
\ \\
  e ::= \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Expression \\
  \ \ \ | \textbf{x} \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Variable \\
  \ \ \ | \textbf{v}  \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Value \\
  \ \ \ | \textbf{x}:= \textbf{e}   \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Assignment \\
  \ \ \ | (\textbf{e} \textbf{e})   \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Pair \\
  \ \ \ | $\lambda$\textbf{x}.\textbf{e}  \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Lambda \\
  \ \ \ | \textbf{e} \textbf{e}   \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Application \\
  \ \ \ |  $\textbf{if}$ $x$ $\textbf{then}$ e $\textbf{else}$ e \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Conditional \\
  \ \ \ |  \textbf{vInsert} e  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Vertex Insert \\
  \ \ \ |  \textbf{vRemove} e  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Vertex Remove \\
  \ \ \ |  \textbf{eInsert} e e   \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  Edge Insert \\
  \ \ \ |  \textbf{eRemove} e e \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  Edge Remove \\
  \ \ \ |  $\textbf{sync}$ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \  \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ Superstep barrier synchronization\\
  \ \ \ |  $\textbf{send}$ x e \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Send message e to vertex x \\
  \ \ \ |  $\textbf{halt}$ \ \ \ \  \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Vote to Halt \\
\ \\
  v ::= \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Value \\
    \ \ \ | $\textbf{v},\textbf{v}$ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Pair value \\
    \ \ \ | \textbf{i} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Integer \\
    \ \ \ | \textbf{b} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Boolean \\
    \ \ \ | $\textbf{(x:T)} \Rightarrow e $ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  User Defined Function \\
    }
\end{frame}

\begin{frame}
  \tiny{
  T ::= \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Type \\
    \ \ \ | \textbf{V}(\textbf{T}) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Vertex Type \\
    \ \ \ | \textbf{E}(\textbf{V(T)}, \textbf{V(T),}\textbf{T})\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  Edge Type\\
    \ \ \ | $\textbf{T} \Rightarrow \textbf{T}$ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ Arrow type \\
    \ \ \ | ($\textbf{T}, \textbf{T}$) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Pair Type \\
    \ \ \ | \textbf{Int} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Integer Type \\
    \ \ \ | \textbf{Bool}\ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  Boolean Type
}
\end{frame}

\subsection{Typing Rule}
\begin{frame}
  \tiny{
\begin{mathpar}
$$\mprset{flushleft}
  \inferrule[\tiny {(Variable)}]
    {\Gamma, \ \Lambda \vdash \textbf{X}=T, \ \Lambda^{'}}
    {\Gamma, \ \Lambda \vdash \textbf{X}:T,\Lambda^{'}}$$
\end{mathpar}

\begin{mathpar}
$$\mprset{flushleft}
  \inferrule[\tiny {(Value)}]
    {\ \ }
    {\Gamma, \ \Lambda  \vdash V:V}$$
\end{mathpar}

\begin{mathpar}
$$\mprset{flushleft}
  \inferrule[\tiny {(Assignment)}]
    {\Gamma, \ \Lambda \vdash e:T, \ \Lambda^{'} \\\\  \Gamma , \ \Lambda^{'} \vdash X:T, \ \Lambda^{"}}
    {\Gamma, \ \Lambda \vdash x::e : T, \ \Lambda^{"}}$$
\end{mathpar}
}
\end{frame}

\begin{frame}
\tiny{
\begin{mathpar}
$$\mprset{flushleft}
  \inferrule[\tiny {(Conditional)}]
    {\Gamma, \ \Lambda \vdash e_1 \ : \ Bool, \ \Lambda \\ \\ \\   \Gamma, \Lambda \vdash e_2 \ : \ T, \ \Lambda^{'} \\\\
    \\ \\ \\ \\ \\ \\ \ \ \ \ \ \ \ \ \ \Gamma, \ \Lambda \vdash e_3 \ : \ T, \ \Lambda^{"}}
    {\Gamma, \ \Lambda \vdash if \ e_1 \ then \ e_2 \ else \ e_3: \ T, \ \Lambda^{'} \uplus \Lambda^{"}}$$
\end{mathpar}

\begin{mathpar}
$$\mprset{flushleft}
  \inferrule[\tiny {(While)}]
    {\Gamma, \ \Lambda \vdash e_1 \ : \  Bool, \ \Lambda \\\\ \Gamma, \ \Lambda \vdash e_2 \ : \ T, \ \Lambda^{'}}
    {\Gamma, \ \Lambda \vdash While \ \ e_1 \ do \ e_2 \ : \ T, \Lambda^{'}}$$
\end{mathpar}

\begin{mathpar}
$$\mprset{flushleft}
  \inferrule[\tiny {(Lambda)}]
    {\Gamma, \ \Lambda, \ x \ : \ T_1 \ \vdash \ e \ : \ T_2, \ \Lambda^{'}}
    {\Gamma, \ \Lambda \vdash  \lambda x.e \ : \ T_1 \rightarrow T_2, \ \Lambda^{'}}$$
\end{mathpar}
}
\end{frame}

\begin{frame}
\tiny{
\begin{mathpar}
$$\mprset{flushleft}
  \inferrule[\tiny {(Application)}]
    {\Gamma, \ \Lambda \vdash e_1 \ : \ T_1 \ \rightarrow \ T_2, \ \Lambda^{'} \\ \\  \Gamma, \ \Lambda^{'} \vdash e_2 \ : \ T_1, \ \Lambda^{"}}
    {\Gamma, \ \Lambda \vdash \ e_1 \ e_2 \ : \ T_2 \ , \ \Lambda^{''}}$$
\end{mathpar}

\begin{mathpar}
$$\mprset{flushleft}
  \inferrule[\tiny {(Vertex Insert)}]
    {\Gamma, \ \Lambda \vdash e_1 \ : \  V(T), \ \Lambda^{'} \\ \\ \Gamma, \ \Lambda^{'} \vdash e_2 \ : \  T, \ \Lambda^{"} \\\\
    \\ \\ \\ \\ \ \ \ \  \Lambda^{'}/\Lambda \neq \phi}
    {\Gamma, \ \Lambda \vdash vInsert \ \ e_1 \ \ e_2 \ :\ \Lambda^{'}/\Lambda, \ \Lambda^{"}}$$
\end{mathpar}

\begin{mathpar}
$$\mprset{flushleft}
  \inferrule[\tiny {(Vertex Remove)}]
    {\Gamma, \ \Lambda \vdash e \ : \ Int, \Lambda^{'}}
    {\Gamma, \ \Lambda \vdash \ vRemove \ e \ : \ \Lambda^{'}/\Lambda}$$
\end{mathpar}
}
\end{frame}

\begin{frame}
  \tiny{
\begin{mathpar}
$$\mprset{flushleft}
  \inferrule[\tiny {(Edge Insert)}]
    {\Gamma, \ \Lambda \vdash e \ : \ E(V(T),\ V(T), T^{'}), \ \Lambda^{'}}
    {\Gamma, \ \Lambda \vdash \ eInsert \ e \ : \ \Lambda^{'}/\Lambda, \ \Lambda^{'}}$$
\end{mathpar}

\begin{mathpar}
$$\mprset{flushleft}
  \inferrule[\tiny {(Edge Remove)}]
    {\Gamma, \ \Lambda \vdash e \ : \ E \ (V(T), V(T), T^{'}), \Lambda^{'}}
    {\Gamma, \ \Lambda \vdash \ eRemove \ e \ : \ \Lambda^{'}/\Lambda, \ \Lambda^{'}}$$
\end{mathpar}
}
\end{frame}


\begin{frame}
  \tiny{
\begin{mathpar}
$$\mprset{flushleft}
  \inferrule[\tiny {(Sync)}]
    {\ \ }
    {\Gamma, \ \Lambda  \vdash sync \ : \ T, \ \Lambda}$$
\end{mathpar}

  \begin{mathpar}
  $$\mprset{flushleft}
    \inferrule[\tiny {(Halt)}]
      {\ \ }
      {\Gamma, \ \Lambda  \vdash halt \ : \ T, \ \Lambda}$$
  \end{mathpar}

\begin{mathpar}
$$\mprset{flushleft}
  \inferrule[\tiny {(Send Message)}]
    {\Gamma, \ \Lambda \ \vdash e_1 \ Int,\ \Lambda^{'} \\\\ \Lambda^{'} \vdash e_2 \ : \ T \ \Lambda^{"}}
    {\Gamma, \ \Lambda, \ \vdash \ send \ e_1 \ e_2 \ : \ Bool, \ \Lambda^{"}}$$
\end{mathpar}
}
\end{frame}

\begin{frame}
  \tiny{
\begin{mathpar}
$$\mprset{flushleft}
  \inferrule[\tiny {(Disjoint\_True)}]
    {\forall \lambda, \lambda \in \Lambda \  | \ \lambda \ is \ a \ value}
    {\Lambda\ : \ Int}$$
\end{mathpar}

\begin{mathpar}
$$\mprset{flushleft}
  \inferrule[\tiny {(Disjoint\_Unknown)}]
    {\exists \lambda, \ \lambda \in \Lambda \ | \ \lambda \ is \ not \ a \ value}
    {\Lambda\ : \ Unknown}$$
\end{mathpar}
}
\end{frame}

\begin{frame}
  \tiny{
\begin{mathpar}

$$\mprset{flushleft}
  \inferrule[\tiny {(M\_Disjoint)}]
     {\Gamma, \ \vdash eInsert \ e \ : \Lambda,\\ \\ a \ = \ value(\Lambda);\ Int  \\\\
      \Gamma, \ \vdash eRemove \ e \ : \Lambda^{'},\\ \ \ b \ = \ value(\Lambda^{'});\ Int \\\\
      \\ \\ \\ \\ \ \ \ \  a \neq b \\\\
      \\ \\ \\ \\ \\ \bigvee \\\\
      \Gamma, \ \vdash vInsert \ e \ : \Lambda,\\ \\ a \ = \ value(\Lambda);\ Int  \\\\
       \Gamma, \ \vdash vInsert \ e \ : \Lambda^{'},\\ \ \ \ \ \  b \ = \ value(\Lambda^{'});\ Int \\\\
       \\ \\ \\ \\ \ \ \ \  a \neq b}
    {\Gamma \vdash \Lambda \ \# \ \Lambda^{'} \ : \ true}$$
\end{mathpar}
}
\end{frame}

\begin{frame}
  \scriptsize {Type judgement for expressions:} \\ \ \\
  \tiny{
  $\Gamma, \ \Lambda \ \vdash \ e \ : \ T, \ \Lambda$ \ \ \  where \\ \ \\
  $\Gamma \ ::= {\{ I \ : \ T_3 \}}_{I \in K}$ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Type environment\\ \ \\
  \ \ \ \ \ \ \ \ where K is finite \\
  \ \\ $\Lambda \ ::= \ \phi \ | \ \Lambda \ \# \ \Lambda$ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Conflict \ disjointness \ check
  }
\end{frame}
